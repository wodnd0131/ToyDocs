import axiosInstance from '@/lib/axios';
import { MeetingMinutes, SlackThread, VoiceFile, ApiResponse, ProcessingResult } from '@/types';
import { mockMeetings } from '@/fixtures/meetings';

class MeetingService {
  private static useFixtures = import.meta.env.VITE_USE_FIXTURES === 'true';
  private static fixtureDelay = parseInt(import.meta.env.VITE_FIXTURE_DELAY || '1000');

  private static async delay(): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, this.fixtureDelay));
  }

  static async getAll(): Promise<MeetingMinutes[]> {
    if (this.useFixtures) {
      await this.delay();
      return mockMeetings;
    }

    try {
      const response = await axiosInstance.get<ApiResponse<MeetingMinutes[]>>('/meetings');
      return response.data.data;
    } catch (error) {
      console.error('Failed to fetch meetings:', error);
      return mockMeetings;
    }
  }

  static async getById(id: string): Promise<MeetingMinutes | null> {
    if (this.useFixtures) {
      await this.delay();
      return mockMeetings.find(meeting => meeting.id === id) || null;
    }

    try {
      const response = await axiosInstance.get<ApiResponse<MeetingMinutes>>(`/meetings/${id}`);
      return response.data.data;
    } catch (error) {
      console.error('Failed to fetch meeting:', error);
      return mockMeetings.find(meeting => meeting.id === id) || null;
    }
  }

  static async create(meetingData: Omit<MeetingMinutes, 'id' | 'createdAt' | 'updatedAt'>): Promise<MeetingMinutes> {
    if (this.useFixtures) {
      await this.delay();
      const mockMeeting: MeetingMinutes = {
        ...meetingData,
        id: Date.now().toString(),
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };
      return mockMeeting;
    }

    try {
      const response = await axiosInstance.post<ApiResponse<MeetingMinutes>>('/meetings', meetingData);
      return response.data.data;
    } catch (error) {
      console.error('Failed to create meeting:', error);
      const mockMeeting: MeetingMinutes = {
        ...meetingData,
        id: Date.now().toString(),
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };
      return mockMeeting;
    }
  }

  static async processSlackThread(thread: SlackThread): Promise<ProcessingResult> {
    if (this.useFixtures) {
      return this.simulateSlackProcessing(thread);
    }

    try {
      const response = await axiosInstance.post<ProcessingResult>('/meetings/process-slack', thread);
      return response.data;
    } catch (error) {
      console.error('Failed to process Slack thread:', error);
      return this.simulateSlackProcessing(thread);
    }
  }

  static async processVoiceFile(file: File): Promise<ProcessingResult> {
    if (this.useFixtures) {
      return this.simulateVoiceProcessing(file);
    }

    try {
      const formData = new FormData();
      formData.append('voice', file);
      
      const response = await axiosInstance.post<ProcessingResult>('/meetings/process-voice', formData, {
        headers: { 'Content-Type': 'multipart/form-data' }
      });
      return response.data;
    } catch (error) {
      console.error('Failed to process voice file:', error);
      return this.simulateVoiceProcessing(file);
    }
  }

  static async processTextMeeting(content: string): Promise<ProcessingResult> {
    if (this.useFixtures) {
      return this.simulateTextProcessing(content);
    }

    try {
      const response = await axiosInstance.post<ProcessingResult>('/meetings/process-text', { content });
      return response.data;
    } catch (error) {
      console.error('Failed to process text meeting:', error);
      return this.simulateTextProcessing(content);
    }
  }

  static async extractIssues(meetingId: string): Promise<ProcessingResult> {
    if (this.useFixtures) {
      await this.delay();
      return {
        success: true,
        data: {
          issues: [
            {
              id: Date.now().toString(),
              title: `회의 ${meetingId}에서 추출된 이슈`,
              description: '픽스처에서 생성된 이슈입니다.',
              assignee: '자동할당',
              priority: 'medium',
              status: 'todo',
              autoGenerated: true,
              source: {
                type: 'manual',
                reference: `Meeting ${meetingId}`
              }
            }
          ]
        },
        processingTime: this.fixtureDelay
      };
    }

    try {
      const response = await axiosInstance.post<ProcessingResult>(`/meetings/${meetingId}/extract-issues`);
      return response.data;
    } catch (error) {
      console.error('Failed to extract issues:', error);
      return {
        success: false,
        error: 'Failed to extract issues from meeting',
        processingTime: 0
      };
    }
  }


  private static async simulateSlackProcessing(thread: SlackThread): Promise<ProcessingResult> {
    return new Promise((resolve) => {
      setTimeout(() => {
        const participants = [...new Set(thread.messages.map(msg => msg.user))];
        const mainTopic = thread.messages[0]?.message.substring(0, 50) + '...';

        resolve({
          success: true,
          data: {
            meeting: {
              id: Date.now().toString(),
              title: `Slack 토론: ${mainTopic}`,
              date: new Date().toISOString().split('T')[0],
              attendees: participants,
              content: thread.messages.map(msg => `${msg.user}: ${msg.message}`).join('\n\n'),
              sourceType: 'slack',
              rawInput: JSON.stringify(thread),
              createdAt: new Date().toISOString(),
              updatedAt: new Date().toISOString(),
              keyPoints: thread.messages.map(msg => msg.message),
              actionItems: [],
              conclusion: '토론을 통해 주요 사안들이 정리됨'
            },
            issues: [
              {
                id: Date.now().toString(),
                title: `토론 주제: ${mainTopic}`,
                description: `Slack 토론에서 도출된 액션 아이템`,
                assignee: participants[1] || participants[0],
                priority: 'medium',
                status: 'todo',
                autoGenerated: true,
                source: {
                  type: 'slack',
                  reference: `Thread #${thread.id}`,
                  extractedFrom: thread.channelName
                }
              }
            ]
          },
          processingTime: 3000
        });
      }, 3000);
    });
  }

  private static async simulateVoiceProcessing(file: File): Promise<ProcessingResult> {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve({
          success: true,
          data: {
            transcription: '음성 파일에서 추출된 회의 내용입니다. [실제 구현시 Web Speech API 또는 외부 STT 서비스 사용]',
            meeting: {
              id: Date.now().toString(),
              title: `음성 회의록 - ${file.name}`,
              date: new Date().toISOString().split('T')[0],
              attendees: ['참여자1', '참여자2'],
              content: '음성에서 추출된 회의 내용...',
              sourceType: 'voice',
              rawInput: file.name,
              createdAt: new Date().toISOString(),
              updatedAt: new Date().toISOString(),
              keyPoints: ['주요 포인트 1', '주요 포인트 2'],
              actionItems: [],
              conclusion: '음성 분석을 통한 회의 요약 완료'
            }
          },
          processingTime: 5000
        });
      }, 5000);
    });
  }

  private static async simulateTextProcessing(content: string): Promise<ProcessingResult> {
    return new Promise((resolve) => {
      setTimeout(() => {
        const lines = content.split('\n').filter(line => line.trim());
        const actionItems = lines.filter(line => 
          line.includes('담당:') || line.includes('할당:') || line.includes('TODO') || line.includes('- ')
        );

        resolve({
          success: true,
          data: {
            meeting: {
              id: Date.now().toString(),
              title: '텍스트 회의록',
              date: new Date().toISOString().split('T')[0],
              attendees: ['작성자'],
              content,
              sourceType: 'manual',
              rawInput: content,
              createdAt: new Date().toISOString(),
              updatedAt: new Date().toISOString(),
              keyPoints: lines.slice(0, 3),
              actionItems: [],
              conclusion: '텍스트 분석을 통한 회의 요약 완료'
            },
            issues: actionItems.map((item, index) => ({
              id: (Date.now() + index).toString(),
              title: item.length > 50 ? item.substring(0, 50) + '...' : item,
              description: `텍스트 회의록에서 추출: ${item}`,
              assignee: '자동할당',
              priority: 'medium' as const,
              status: 'todo' as const,
              autoGenerated: true,
              source: {
                type: 'manual',
                reference: '텍스트 회의록'
              }
            }))
          },
          processingTime: 2000
        });
      }, 2000);
    });
  }
}

export default MeetingService;